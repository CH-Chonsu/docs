---
sidebar_position: 3
title: Pink Mobile Demo Application
---

Pink Mobile is a simple mobile plan management application that demonstrates the basic principles of fine-grained authorization by using impersonation of three different user personas: Customer, Representative, and Manager.

By utilizing this application in a simple web application based on Node.js, you can learn how to model fine-grained authorization using Permit.io, and how to enforce the policy decisions in your application.

Take a look at the application in action üëáüèª
<div className={"arcade-demo-container"} style={{height: '100%', padding: 0}}>
	<iframe
		src="https://demo.arcade.software/JIkRxYCj6SRhyo2aNe24?embed"
		frameborder="0"
		loading="lazy"
		webkitallowfullscreen
		mozallowfullscreen
		allowfullscreen
        style={{width: '500px', height: '730px', position: 'relative'}}
		className={"arcade-demo-iframe"}
	></iframe>
</div>

## Modeling Fine-Grained Authorization

The first step in understanding fine-grained authorization is proper policy modeling of our needs. In the following document, we are using the plane model to understand the different aspects of policy modeling.

One of the benefits of the plane model for fine-grained authorization is its way of decoupling the **control plane** (the configuration of the rules), the **data plane** (the data that helps us make decisions), and the **enforcement plane** (the actual enforcement of the rules). This decoupling helps us ensure that the policy is streamlined and easy to manage.

In the following sections, we will go over each of the planes and see how our application deals with them.
:::tip
While we are using the Permit.io Node.js SDK to configure permissions, you can also use the [Permit.io dashboard](https://app.permit.io) to configure fine-grained authorization for your application.
:::


## Control Plane

The control plane is where we configure all the policy rules and the entities required to create those fine-grained rules. Here's a diagram with the entities we are using in our application:

![Control Plane Entities](/img/modeling/pink-mobile/control-plane-entities.png)

:::info
You can view all the configuration below in the [setup.js](https://github.com/permitio/pink-mobile-demo-app/blob/main/setup.js) file
:::

Let's go over each of the entities and see how we configured them in our application üëáüèª

### Resources

The first step in protecting data is understanding the resources we want to protect. In Pink Mobile, we have four types of resources:

- User: the customer who might want an agent to manage their plan
- Representative: an entity of an agent that can manage the customers
- Account: the top-level resource for everything related to the user (e.g., personal details)
- Plan: the plan that the user is using

Of course, in a real mobile management application, there are many more resources, but for the sake of simplicity, we'll use these four resources.

The following code from the `setup.js` file is an example of setting up the `Representatives` resource:

```javascript
await permit.api.resources.create({
    key: "representatives",
    name: "Representatives",
    actions: {
      list: {
        name: "List",
      },
      assign: {
        name: "Assign",
      },
    },
  });
```

#### Resource Relationships

As we mentioned, the account resource is acting as a top-level resource for the user. This means that we might want to propagate the same permissions to resources that are related to the account. For example, if a user is allowed to perform some operations on their account, we might want to allow them to perform the same operations on their plan.

To create such kind of relationship, we need to declare the relations between resources in our system. Here's an example of how we can declare the relationship between the `Account` and the `Plan` resources using the Permit.io Node.js SDK:

```javascript
await permit.api.resources.create({
    key: "plan",
    name: "Plan",
    ...
    relations: {
      parent: "account",
    },
  });
```

### Roles

Now that we model and configured the resources, we can define the roles that are allowed to perform operations on these resources. In Pink Mobile, we can identify the following roles:

#### Environment-level Roles

This roles will allow to the users belonging to the role to perform operations on all the resources from a paritcular types in the environment.

- Manager - can perform some operations on all the representaitves in the system
- Representative - can perform some operations on all the users in the system

Here's a code example of adding the `Manager` role to the environment using Permit.io Node.js SDK:

```javascript
await permit.api.roles.create({
    key: "manager",
    name: "Manager",
    permissions: [
      "representatives:assign",
      "account:view",
      "users:create",
      "representatives:list",
      "plan:view",
      "users:list",
    ],
  });
```

#### Resource-level Roles

This roles are more fine-grained, and allow to perform operations on a specific resource that a user is assigned to. We will write this role in the follwoing convention: `Resource#Role`

- Account#Owner - can perform all operations on the user's account
- Account#Member - can perform some viewing operations on the user's account
- Account#Editor - can perform some editing operations on the user's account
- Plan#Editor - can perform some editing operations on the user's plan

Here's a code example of adding the `Account#Owner` role as part of the resource configuration using Permit.io Node.js SDK:

```javascript
await permit.api.resources.create({
    key: "plan",
    name: "Plan",
    ...
    roles: {
      editor: {
        name: "Editor",
        permissions: ["view", "change"],
        ...
      },
    },
    ...
  });
```

#### Role Derivations

Looking at the previous list, we can see some hierarchy in the roles same as we had with resources. For example, we might want to give a user with a particular role on the account, some other permissions on resources that related to this account. For example, plans.
To do so, we can configure a role derivation that will allow us to derive the permissions from the account to the plan. We will configure then the following role derivation:

- `Account#Editor` -> `Plan#Editor` - every user that has the `Account#Editor` role, derive all the relevant permissions in the `Plan#Editor` role.

Here's a code example of adding the role derivation to the environment using Permit.io Node.js SDK:

```javascript
await permit.api.resources.create({
    key: "plan",
    name: "Plan",
    ...
    roles: {
        editor: {
        name: "Editor",
        permissions: ["view", "change"],
        granted_to: {
            users_with_role: [
            {
                role: "editor",
                on_resource: "account",
                linked_by_relation: "parent",
            },
            ],
        },
        },
    },
    ...
});
```

### Conditions

To create even fine-grained authorization, we can levarage our resource and user attributes to create condition sets based on our resources. Creating such conditions will give us later the option to match them in the policy and allow or deny the operation based on the condition.

#### User Sets

The first type of condition we can create is a user set. A condition (or set of conditions) that based on the user attributes. In our application, we will create the following conditions:

| User Set | Condition | Description |
| --- | --- | --- |
| Blocked Users | `user.blocked == true` | A condition that checks if the user is blocked |
| Active Users | `user.blocked == false` | A condition that checks if the user is active |

Here's is an example of how to create the `Blocked Users` condition using the Permit.io Node.js SDK:

```javascript
await permit.api.conditionSets.create({
    key: "blocked_users",
    name: "Blocked Users",
    type: "userset",
    conditions: {
      allOf: [{ allOf: [{ "user.blocked": { equals: true } }] }],
    },
});
```

#### Resource Sets

The second type of condition we can create is a resource set. A condition (or set of conditions) that based on the resource attributes. In resource set, we can also match user attributes with resource attributes to test things like ownership. In our application, we will create the following conditions:

| Resource Set | Condition | Description |
| --- | --- | --- |
| Owned Resources | `resource.owner == user.id` | A condition that checks if the user is the owner of the resource |

Here's is an example of how to create the `Owned Resources` condition using the Permit.io Node.js SDK:

```javascript
await permit.api.conditionSets.create({
    key: "owned_plans",
    name: "Owned Plans",
    type: "resourceset",
    resource_id: "plan",
    conditions: {
      allOf: [
        { allOf: [{ "resource.owner": { equals: { ref: "user.key" } } }] },
      ],
    },
});
```

### Policy Rules

At this point, we have all the blocks required to create a fine-grained policy table for our application. Looking at Permit.io dashboard, this is how our application policy table might look like:
![Policy Editor](/img/modeling/pink-mobile/policy-editor.png)

To setup this policy, we used the Permit.io API in the setup script. For example, here's where we assigned the active users permissions to perform operations on their owned resources:

```javascript
await permit.api.conditionSetRules.create({
    user_set: "active_users",
    resource_set: "owned_plans",
    permission: "plan:view",
});
await permit.api.conditionSetRules.create({
    user_set: "active_users",
    resource_set: "owned_plans",
    permission: "plan:change",
});
```

## Data Plane

The data plane is the layer where we setup the data that would help our authorization service to get the proper decisions. For example, we would want to let the policy engine to know our user roles, attributes, etc.

Our application is dealing with the following data plane entities:

### Users

The most basic entity in every authorization data plane, is the users themselves. Their basic information and the unique ID that will help us to match them with the resources they are allowed to perform operations on.

In a standard application, you would like to connect Permit's `sync` user function to your authentication provider. In our application, we used the Setup.js script to configure 6 users from the Harry Potter world, and assign each of them different roles and attributes. Here's an example of how we configured the `Sirius Black` user:

```javascript
permit.api.users.sync({
    email: "sirius@pink.mobile",
    key: "sirius@pink.mobile",
    first_name: "Sirius",
    last_name: "Black",
    attributes: {},
});
```

### User Roles

For each user in our applciation, we would like to assign one or more resource or environment roles. This will help us to match the user with the proper permissions in the policy table.

Here's an example of how we assigned the `Representative` role to the `Sirius Black` user:

```javascript
await permit.api.roleAssignments.assign({
    role: "representative",
    user: "sirius@pink.mobile",
    tenant: "default",
});
```

Here's another example of a resource-role assignment, where we assign `harry@potter.io` the `Account#Owner` role for his particular account instance:

```javascript
await permit.api.roleAssignments.assign({
    role: "owner",
    resource_instance: `account:harry`,
    user: "harry@potter.io",
    tenant: "default",
});
```

### Relationship Tuples

In order to ensure the role derivation is correctly derive roles from one resource to another, we need to create the relationship tuples between the resources. In our application, we used the Setup.js script to configure the relationship tuples between the resources. Here's an example of how we configured the relationship between Harry's account and Harry's plan:

```javascript
await permit.api.relationshipTuples.create({
    subject: `account:harry`,
    object: `plan:harry`,
    relation: "parent",
    tenant: "default",
})
```

## Enforcement Plane

In the enforcement plane, we will enforce the policy decisions with the configuration from the control plane and the data from the data plane. In our application, we are using the Permit.io Node.js SDK to enforce the policy decisions.

### The Check Function

In the authorizer.js file, you'll find a function that is responsible for enforcing the policy decisions. Here's an example of how we enforce the policy decisions for the `Change Plan` operation:

```javascript
export const authorize = async (user, action, resource) => {
  return permit.check(user, action, resource);
};
```

The `permit.check` function that we are using to enforce permissions, will take the current user, the operation, and the resource, and will return a decision based on the policy table that we configured in the control plane, and the data that we configured in the data plane.

### Data Filtering

Another way to enforce permissions, is query the Permit APIs for particular roles and data to ensure we are not exposing data that the user is not allowed to see. In our application, we are filtering the allowed representatives and their allowed users by query the relevant roles in Permit configuration.
Here's an example of how we are filtering only the users that are owners of a plan:

```javascript
const owners = await permit.api.roleAssignments.list({
    tenant: "default",
    role: "owner",
  });
```

## Get Started
To learn more on the application itself, and run it locally, you can visit the [Pink Mobile Demo Repository](https://github.com/permitio/pink-mobile-demo-app) on GitHub. If you need any help, feel free to reach out to us on our [Slack channel](https://io.permit.io/blog-slack).
---
sidebar_position: 2
title: Authorization Concepts
---

# Authorization Concepts

### Authorization(AuthZ) vs Authentication (AuthN)

While closely related AuthZ and AuthN are very different things.
To simplify with a metaphor - imagine someone about to enter your home:

- **Authentication (AuthN) - Who is the user**

Deals with identifying who is at the door, and deciding whether they may enter.
Also known as login.

- **Authorization (AuthZ) - What is the user allowed to do**

Deals with the policy and permissions someone has once they enter (e.g. can they eat in the kitchen? Can they use the toilet? May they sleep in the bed? Can they read your diary? Can they drink all the rum and burn the house down? Can they invite their friends to reenact the battle of Gettysburg in your linen closet?)

### Decoupling Policy from Code

One of the key challenges of getting authorization right is to support its growing complexity throughout the life of a software solution.
Authorization complexity can be broken into two key parts - Architectural and Feature/Model complexities.

Architectural complexity

With time (and especially with the growth of microservices and distributed elements) as more authorization logic is added, code handling it in different components begins to drift apart (As different developer teams solve for specific cases.

Feature and model complexity
Every dev-team always starts with - &quot;we only need 'Admin' and 'Not Admin', but quickly discovers that more roles, models, rules, controls, and data are required as more demands arrive from customers, colleagues, security, compliance, and partners.
Soon RBAC is replaced by ABAC, GBAC, and/or other hybrid models; and more and more access-control features are built on top.

Decoupling Policy and Code in general
To avoid being encumbered by said complexity we can use the best practice of decoupling policy from code. In which we ideally use a separate microservice to provide authorization to the rest of the system. Open-source solutions like Open-Policy-Agent and its policy language Rego, are a great baseline for creating such a microservice, but still require a lot of handling and maintenance, especially around connecting the microservice to the application, its policy sources, the data it needs, and the access-control interfaces we need to build on top.

Decoupling Policy and Code with Permit.io

With Permit.io you get a ready microservice (based on OPA+OPAL) out of the box, SDKs per your language of choice to work with said microservice, and a ready cloud service to manage it all.

### Decoupling Authorization data from application data

While the information for running the product or service overlaps with the data used for authorizing access to it - the two aren't the same. Often the authorization doesn't require all the data that is used by the application, and the data relevant for authorization often extends to additional data sources that are not a core part of the application (e.g. billing, CRM, ERP, identity providers).

Decoupling policy and code with Permit.io

Permit.io provides easy data integrations from multiple sources, through custom integrations and a pipeline based on OPAL.

### Multi-tenancy

Most modern applications (and especially microservices based ones) require some degree of multi-tenancy - allowing the application to serve multiple customers at once - while sharing the underlying infrastructure and services, allowing for load balancing and scaling, and most importantly secure and compliant access separation.

An authorization layer is the fastest, and most robust way to safely upgrade from a single tenant application to a multi-tenant application. By applying a policy across all the relevant services, the authorization layer can apply the needed separation without requiring changes to the services themselves.

---
sidebar_position: 1
title: GraphQL
---

## GraphQL Integration

The utilization of GraphQL APIs for retrieving information from different datastores and microservices has gained widespread popularity. 
In order to ensure appropriate access control, applications or services providing GraphQL APIs often require the ability to manage the users who can execute queries, mutations, and other actions.
With Permit, it becomes effortless to develop detailed and situational policies that can be utilized to enforce GraphQL query authorization.


### Ways to enforce permissions into your GraphQL API

When you need to integrate permissions into your GraphQL API, you can do it in multiple ways.

#### Add permissions to your GraphQL resolvers
One simple way would be to add permit check in the resolver function of your GraphQL API.
This way while simple to implement, it can be cumbersome to maintain and scale as the number of resolvers increase.

#### Add permissions to your GraphQL schema
Another way would be to add permissions to your GraphQL schema.
This way is more scalable and easier to maintain, but it still requires you to manage the permissions mapping in multiple places.
```graphql
type Book {
  title: String
  author: Author 
  rating: Int @permit(resource:"book_rating", action: "get")
}

type Author {
  name: String
  books: [Book] @permit(resource:"author_books", action: "get")
}
```

#### Add permissions to your GraphQL using Middleware/Plugins
Another way would be to add permissions to your GraphQL using Middleware/Plugins.
This way requires you to have a mapping object that maps the GraphQL schema to the Permit policy.
```javascript
const PermissionMap = {
  "login": {resource: "user", action: "login"},
  "logout": {resource: "user", action: "logout"},
  "me": {resource: "user", action: "get"},
  "launches": {resource: "launch", action: "getall"},
  "getlaunch": {resource: "launch", action: "get"},
}
```

You can also detect the resource and if this is a query or mutation from the GraphQL context, and manage the mapping accordingly.
```javascript
      async didResolveOperation (context) {
        const op = context.operationName
        var user = await getUserFromJWT("");
        isMutation = context.operation.operation === 'mutation'
        const allowed = await permit.check(user, isMutation? "write": "read", op.toLowerCase()) // this will look like "user:write:launches" or "user:read:launches"
        if (!allowed) {
          throw new Error("Not allowed");
        }
    }
```
In this tutorial we will implement this approach using the [Apollo Server](https://www.apollographql.com/docs/apollo-server/).
[apollo server and permit tutorial](https://docs.permit.io/integrations/GraphQL/apollo_server)




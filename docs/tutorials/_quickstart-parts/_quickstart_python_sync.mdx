## Add the SDK to your Python code (sync)

Init the Python SDK and check for permissions.

1. Install the Permit.io SDK:

```
pip install permit
```

2. Add the SDK to your code (in the top of your py file):

Notice that you need to import the class `Permit` from `permit.sync` to get the sync-python SDK:

```python
from permit.sync import Permit
```

3. Create a new instance of the SDK:
   You can find instructions on getting a secret API key in the previous section

```python
# This line initializes the SDK and connects your python app
# to the Permit.io PDP container you've set up.
permit = Permit(
    # in production, you might need to change this url to fit your deployment
    pdp="http://localhost:7000",
    # your secret api key
    token="<your-api-key>",
)
```

## Check API (Check permissions)

You can run a permission check with `permit.check()`, you will need 3 arguments:

- `user_id`: a unique string id that identifies the user doing the action.
- `action`: the action performed.
- `resource`: the resource (object) the action is performed on.

In the following example we are checking the a user with id `jack@pirates.com` can `create` a `document` resource:

```python
permitted = permit.check("jack@pirates.com", "create", "document")

if permitted:
    print("Jack is permitted to create a document")
else:
    print("Jack is NOT PERMITTED to create document!")
```

Permission checks are being run against the PDP container with minimal latency and without leaving your network.

## Write API

The `permit.write()` api will perform API calls against the Permit cloud and will modify
the state of permissions and other objects in the system.

### Sync user (create a user in the permissions system)

Before being able to check permissions with `permit.check()`,
Permit must be able to identify the user and attach permissions and roles to that user.
In order to declare a new user in the system, use `permit.api.sync_user()`:

```python
user = {
    "key": "jack@pirates.com", # can be any unique string
    "firstName": "Jack", # optional
    "lastName": "Sparrow", # optional
    "email": "jack@pirates.com", # optional
}
permit.write(permit.api.sync_user(user))
```

### Sync user with initial roles

If you want to attach a role to a user in the same api call you can define (initial) roles by adding a roles key.
Each item in the (initial) roles list will include a role key (the role name) and a tenant key.

```python
user = {
    "key": "jack@pirates.com",
    "firstName": "Jack",
    "lastName": "Sparrow",
    "email": "jack@pirates.com",
    # jack will be assign the admin role in the default tenant upon creation
    "roles": [{"role":"admin", "tenant": "default"}]
}
permit.write(permit.api.sync_user(user))
```

:::note
If a user with such key already exists on permit, we will not override the user roles and Permit will ignore the roles key completely.
:::

### Create tenant

Tenants represent user and resource boundaries in your system. Typically if you are building
a multi tenant SaaS application where you are serving multiple customers from the same software
instances, _tenants_ allow you to create a **boundary** around one customer (i.e: tenant) such that users outside
the tenant cannot access the tenant's associated resources.

Every one of your customers is typically a tenant that contains only that tenant's users.

To create a tenant, use `permit.api.create_tenant()`:

```python
cool_company_tenant = {
    "key": "cool_company_inc",
    "name": "Cool Company Inc"
}

permit.write(permit.api.create_tenant(cool_company_tenant))
```

### Assign role

You can assign a role to a user in a given tenant:

```python
permit.write(
    permit.api.assign_role("jack@pirates.com", "viewer", "cool_company_inc")
)
```

### Chaining multiple mutations together

You can chain multiple write operations (or mutations), and `permit.write()`
will run them according to the order you specify.

```python
# runs the mutations in order:
permit.write(
    # first creates the user "jack"
    permit.api.sync_user({
        "key": "jack@pirates.com",
        "firstName": "Jack",
        "lastName": "Sparrow",
        "email": "jack@pirates.com",
    }),
    # then, creates the "black-pearl" tenant
    permit.api.create_tenant({
        "key": "black-pearl",
        "name": "the black pearl"
    }),
    # finally, assigns the role "admin" to user "jack" on the tenant "black-pearl"
    permit.api.assign_role("jack@pirates.com", "admin", "black-pearl")
)
```

## Full app example

The following is a Python app with a single file, with the `permit` and `FastAPI` modules installed.

Create a new directory for your new python project:

```
mkdir hello-permissions && cd hello-permissions
```

Optionally, create a new virtual environment for your project (you might need to install pyenv and pyenv-virtualenv):

```
pyenv virtualenv permissions && pyenv activate permissions
```

Now install the Permit.io SDK (We'll also install the FastAPI and Uvicorn packages in order to run an HTTP server in our example):

```
pip install permit flask
```

Create a file called test.py:

```
touch test.py
```

Copy the following code inside test.py and replace with your `api key` and `user-object`:
You can find instructions on getting a secret API key in the previous section

```python
import json

from permit.sync import Permit

from flask import Flask, Response

app = Flask(__name__)

# This line initializes the SDK and connects your python app
# to the Permit.io PDP container you've set up in the previous step.
permit = Permit(
    # in production, you might need to change this url to fit your deployment
    pdp="http://localhost:7000",
    # your api key
    token="[YOUR_API_KEY]",
)

def sync_objects():
    # first let's create a user:
    user = {
        "key": "jack@pirates.com",
        "firstName": "Jack",
        "lastName": "Sparrow",
        "email": "jack@pirates.com",
        "roles": [{"role":"admin", "tenant": "default"}]
    }
    permit.write(permit.api.sync_user(user))

    tenant2 = {
        "key": "tenant2",
        "name": "Second Tenant"
    }

    # create tenant 2 and assign role viewer to user jack
    permit.write(
        permit.api.create_tenant(tenant2),
        permit.api.assign_role("jack@pirates.com", "viewer", "tenant2")
    )

sync_objects()

@app.route("/")
def check_permissions():
    # After we created this user in the previous step, we also synced the user's identifier
    # to permit.io servers with permit.write(permit.api.syncUser(user)). The user identifier
    # can be anything (email, db id, etc) but must be unique for each user. Now that the
    # user is synced, we can use its identifier to check permissions with `permit.check()`.
    permitted = permit.check("jack@pirates.com", "retrieve", "task") # default tenant is used
    if not permitted:
        return Response(json.dumps({
            "result": f"Jack Sparrow is NOT PERMITTED to retrieve task!"
        }), status=403, mimetype='application/json')

    return Response(json.dumps({
            "result": f"Jack Sparrow is PERMITTED to retrieve task!"
        }), status=200, mimetype='application/json')

@app.route("/tenant2")
def check_permissions_tenant2():
    # After we created this user in the previous step, we also synced the user's identifier
    # to permit.io servers with permit.write(permit.api.syncUser(user)). The user identifier
    # can be anything (email, db id, etc) but must be unique for each user. Now that the
    # user is synced, we can use its identifier to check permissions with `permit.check()`.
    permitted = permit.check("jack@pirates.com", "create", {"type": "task", "tenant": "tenant2"}) # tenant2 is used
    if not permitted:
        return Response(json.dumps({
            "result": f"Jack Sparrow is NOT PERMITTED to create task (tenant 2)!"
        }), status=403, mimetype='application/json')

    return Response(json.dumps({
            "result": f"Jack Sparrow is PERMITTED to create task (tenant 2)!"
        }), status=200, mimetype='application/json')

```

Now that your application is ready, let's run it:

```
FLASK_APP=test flask run --host=0.0.0.0
```

Finally, go to [http://localhost:5000](http://localhost:5000) to see the outcome of the permission check.

---
sidebar_position: 1
title: Modeling Google Drive Permissions
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Modeling Google Drive Permissions with ReBAC

This tutorial explains how to build a simplified [Google Drive](https://www.google.com/drive/)-like permission system using [Permit.io](https://permit.io).

:::info Early Access Feature
**[ReBAC](https://en.wikipedia.org/wiki/Relationship-based_access_control)** (relationship based access control) is now in early access. &nbsp; **[Contact us](https://bit.ly/permit-slack)** to try it out.
:::

## Before you begin

1. [Sign up to Permit.io](tutorials/onboarding/lets-begin.mdx)
2. [Get your environment API Key](tutorials/quickstart.mdx#get-your-permitio-environment-api-key)
3. (optionally) Install and init the Permit SDK (if you are not calling the API directly)

### Early access SDKs

You will need to install an early-access version of the SDKs to use ReBAC functions.

<Tabs groupId="language">
  <TabItem value="python" label="Python">

To install the early access python SDK:

```sh
pip install permit==2.1.0rc1
```

All other instructions from the [Python quickstart](/sdk/python/quickstart-python) remain the same.

  </TabItem>
  <TabItem value="node" label="Node.js">

To install the early access Node.js SDK:

```sh
npm install permitio@2.1.0-rc.0
```

All other instructions from the [Node.js quickstart](/sdk/nodejs/quickstart-nodejs) remain the same.

  </TabItem>
  <TabItem value="java" label="Java">

To install the early access Java SDK you'll need version `1.4.0-rc`.

For [Maven](https://maven.apache.org/) projects, use:

```xml
<dependency>
  <groupId>io.permit</groupId>
  <artifactId>permit-sdk-java</artifactId>
  <version>1.4.0-rc</version>
</dependency>
```

For [Gradle](https://gradle.org/) projects, configure `permit-sdk-java` as a dependency in your `build.gradle` file:

```groovy
dependencies {
    // ...

    implementation 'io.permit:permit-sdk-java:1.4.0-rc'
}
```

All other instructions from the [Java quickstart](/sdk/java/quickstart-java) remain the same.

  </TabItem>
</Tabs>

### Setup your environment

If you are calling the API directly using cURL or Postman, you'll need to setup a few environment variables.
Alternatively if you are working with one of the Permit SDKs, you'll need to initialize the SDK with your API key.

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

For cURL/Postman, setup the following environment variables:

```bash
export permit_project="<your-project-key>" # for example: the `default` project
export permit_env="<your-environment-key>" # for example: the `dev` environment
export permit_sdk_api_key="<your-api-key>" # for example: `permit_key_...`
```

The API key you should use for your API calls must be an [environment-level API key](tutorials/quickstart.mdx#get-your-permitio-environment-api-key).

  </TabItem>
</Tabs>

## What you will be building

Google drive is a system you can use to store, share, and collaborate on files and folders.

The G-Drive permission model is [documented here](https://developers.google.com/drive/api/guides/ref-roles).
For simplicity we will implement a subset of it with Permit.

### Requirements

1. **Object Hierarchy:** A google drive account can contain many folders and files. Folders can contain other files and folders.
2. **Direct file access:** A user can be a viewer of file, a commenter (meaning they can view and comment on the contents) or an editor (can view, comment and edit).
3. **Folder-level access:** A user can be granted access to a folder. A user access level on a certain folder will grant that same access level on all the files within the folder.
4. **Account admin access:** A user can be granted admin access to the entire account, which will grant the highest permission level on all folders and files within the account.
5. **General access to "Everyone in account":** Files can be shared with all the users who are associated with the account that contains the file (share with all account members).

### Test objects

To verify our system work, we will define the following users:

We're going to create a few users, a few folders and a few files, establish the relationships between them, assign some roles, and then see how permission checks take what we've defined into account.

TBD

## Modeling the Resource Graph

### Define resources and roles

#### Resources

**Resources** in Permit are types of objects that you can enforce permissions on. Each resource has a predefined set of actions that a user can perform on it.

Permit ReBAC allows you to model your resources as a graph.
Each resource (a type) is a node in the graph, and can connect to other resources via edges called **relations**.

The resources we will define for this example are:

```
- Account
- Folder
- File
```

#### Resource Roles

Each resource type can define its own roles. A **resource role** represents an access level (or a set of permissions) that can be granted on instances of a specific resource type.

Resource roles are typically denoted as `Folder#editor`, which means "a resource role with key `editor` that is defined on the resource type with key `Folder`".

The resource roles we will define are:

```
- Account#admin
- Account#member

- Folder#editor
- Folder#commenter
- Folder#viewer

- File#editor
- File#commenter
- File#viewer
```

#### The Account Resource

The `Account` resource type represents an organization's account in Google Drive. Later in the tutorial, we'll create a specific instance of this resource type for our fictional company, ACME, Inc.

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "account",
    "name": "Account",
    "actions": {
        "invite-member": {},
        "list-members": {},
        "remove-member": {}
    },
    "roles": {
        "admin": {
            "name": "Admin",
            "permissions": [
				"invite-member",
				"list-members",
				"remove-member"
			]
        },
        "member": {
            "name": "Member",
            "permissions": [
				"list-members"
			]
        }
    }
  }'
```

  </TabItem>
</Tabs>

We've created the `Account` resource, with three actions: `invite-member`, `list-members`, and `remove-member`.

We've also created two roles, `admin` and `member`. The `admin` role has permission to perform all actions, while the `member` action can only perform `list-members`.

Let's do the same with the `Folder` and `File` resource types.

#### The Folder Resource

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "folder",
    "name": "Folder",
    "actions": {
        "list-files": {},
        "create-file": {},
        "rename": {}
    },
    "roles": {
        "editor": {
            "name": "Editor",
            "permissions": [
				"list-files",
				"create-file",
				"rename"
			]
        },
        "commenter": {
            "name": "Commenter",
            "permissions": [
				"list-files"
			]
        },
        "viewer": {
            "name": "Viewer",
            "permissions": [
				"list-files"
			]
        }
    }
  }'
```

  </TabItem>
</Tabs>

Note that for the `Folder` resource, we've defined two identical roles - `commenter` and `viewer`. &nbsp;Don't worry, we'll address this later on.

#### The File resource

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "file",
    "name": "File",
    "actions": {
        "read": {},
        "comment": {},
        "update": {},
        "delete": {}
    },
    "roles": {
        "editor": {
            "name": "Editor",
            "permissions": [
				"read",
				"comment",
				"update",
				"delete"
			]
        },
        "commenter": {
            "name": "Commenter",
            "permissions": [
				"read",
				"comment"
			]
        },
        "viewer": {
            "name": "Viewer",
            "permissions": [
				"read"
			]
        }
    }
  }'
```

  </TabItem>
</Tabs>

### Define relations

A **relation** is a type of an edge in the graph between two resources.

A relation called `parent` between a `File` resource and a `Folder` allows you to create **relationship tuples** of this type between a `File` instance and a `Folder` instance.

In other words, a relation is a **type** of a relationship (i.e: relationship tuple).

Example relation:

```
File -> parent -> Folder
```

Example of a relationship tuple of this type:

```
(Folder:soc2, parent, File:access-control-policy)
```

The relations we will define are:

```js
Folder.account -> Account // relation from folder to its parent account
File.account -> Account // relation from file to its parent account
Folder.parent -> Folder // relation from folder to its parent folder
File.parent -> Folder // relation from file to its parent folder
```

:::info The direction of relations/relationships
Note that the direction of a relation is typically **from the object resource to the subject resource**.
However for relationships, we read the relationship tuple **from the subject to the object**, in the reverse direction.
:::

#### File -> parent -> Folder

We'll define the parent relation, linking a file to the folder that contains it. As discussed before, relations define the kind of links that can exist between resource instances, so we define them on their corresponding resource types.

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/relations \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "parent",
    "name": "Parent",
    "subject_resource": "folder"
  }'
```

  </TabItem>
</Tabs>

Note that the relation is defined on the `file` resource `/relations` endpoint. A relation will always be defined on the **object** resource. Within the request body, you must specify the **subject** resource (the resource where the relation points to).

#### Folder -> parent -> Folder

Obviously, folders can also be in folders, so let's create that as well. Note that this relation is recursive, which means that it points from a resource type to itself, but the relationships that are defined using them will not necessarily be from an resource instance to itself - usually they'll point to another instance of the same type.

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/folder/relations \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "parent",
    "name": "Parent",
    "subject_resource": "folder"
  }'
```

  </TabItem>
</Tabs>

And let's create the two relations linking files and folders to their account:

#### Folder -> account -> Account

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/folder/relations \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "account",
    "name": "Account",
    "subject_resource": "account"
  }'
```

  </TabItem>
</Tabs>

#### File -> account -> Account

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/relations \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "account",
    "name": "Account",
    "subject_resource": "account"
  }'
```

  </TabItem>
</Tabs>

### The model so far

In this diagram:

- **Resources** are denoted by black circles
- **Resource Roles** are denoted by <span style={{color: "blue"}}>blue circles</span>
- **Resource Relations** are denoted by black edges (or arrows)

![Resource Window](/img/rebac/resource_roles.png)

## Implementing Google Drive's Permissions

### 1. Direct file access

Let's define some users and grant them permissions!

We'll create a resource instance of type Account that represents our company, ACME, Inc.
In following calls, this resource will be referred to `account:acme`, as its resource type key is `account` and its instance key is `acme`.

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/resource_instances \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "resource": "account",
    "key": "acme",
    "tenant": "default"
  }'
```

  </TabItem>
</Tabs>

Let's also create a folder and a file:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/resource_instances \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "resource": "folder",
    "key": "finance",
    "tenant": "default"
  }'
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/resource_instances \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "resource": "file",
    "key": "2023_report",
    "tenant": "default"
  }'
```

  </TabItem>
</Tabs>

And finally, two users:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/users \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "jane@acme.com"
  }'
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/users \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "john@acme.com"
  }'
```

  </TabItem>
</Tabs>

The simplest thing we can do is assign files to users. A Role Assignment can point at an entire resource type (as in RBAC, which is not what we're using in this tutorial), or in our case, to a specific resource instance (ReBAC).

Let's give John read-only access (i.e. the `viewer` role) to the 2023_report file:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/role_assignments \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "user": "john@acme.com",
    "role": "viewer",
    "resource_instance": "file:2023_report"
  }'
```

  </TabItem>
</Tabs>

### 2. Folder-level access

Just like we can give permissions on files, we can do the same on folders. Let's grant Jane the `editor` role on our folder, finance:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/role_assignments \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "user": "jane@acme.com",
    "role": "editor",
    "resource_instance": "folder:finance"
  }'
```

  </TabItem>
</Tabs>

### 3. Folder permissions propagate to child files and folders

Note that while now Jane can `list-files`, `create-file` and `rename` the folder, she can't actually access files in the folder. In fact, there are no files in the folder. Let's fix that.

First, we'll create a parent relationship from the 2023_report file to the finance folder:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/facts/$permit_project/$permit_env/relationship_tuples \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "subject": "folder:finance",
    "relation": "parent",
    "object": "file:2023_report"
  }'
```

  </TabItem>
</Tabs>

Then, we'll change the schema slightly and add a role derivation. When a user has a role on a specific resource instance, and there is a role derivation on that resource type, the user will also get the derived role on any resource instances that have the derivation's specified relationship with that original resource instance.

For example, we want anyone who has the `editor` role on a folder, to automatically get the `editor` role on any file contained within that folder, that is, any file that has a parent relationship with that folder.

Let's define that:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/roles/editor \
  -X PATCH \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "granted_to": {
        "users_with_role": [
            {
                "linked_by_relation": "parent",
                "on_resource": "folder",
                "role": "editor"
            }
        ]
	}
  }'
```

  </TabItem>
</Tabs>

We'll do the same to also propagate the other roles:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/roles/commenter \
  -X PATCH \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "granted_to": {
        "users_with_role": [
            {
                "linked_by_relation": "parent",
                "on_resource": "folder",
                "role": "commenter"
            }
        ]
	}
  }'
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/roles/viewer \
  -X PATCH \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "granted_to": {
        "users_with_role": [
            {
                "linked_by_relation": "parent",
                "on_resource": "folder",
                "role": "viewer"
            }
        ]
	}
  }'
```

  </TabItem>
</Tabs>

Note that now finally the `commenter` role on a folder is different from the `viewer` role, because different roles on files are derived from them.

### 4. Account admin permissions

Now that we've granted specific permissions to the folder, let's do the same to the acme Account. Since role derivations propagate recursively, associating a folder with an account will grant permissions not only on that folder, but also on the files it contains.

Let's give anyone who has the `admin` role on an account also have the `editor` on any folder and file within it:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/folder/roles/editor \
  -X PATCH \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "granted_to": {
        "users_with_role": [
            {
                "linked_by_relation": "account",
                "on_resource": "account",
                "role": "admin"
            }
        ]
	}
  }'
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/roles/editor \
  -X PATCH \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "granted_to": {
        "users_with_role": [
            {
                "linked_by_relation": "account",
                "on_resource": "account",
                "role": "admin"
            }
        ]
	}
  }'
```

  </TabItem>
</Tabs>

### 5. General access to "Everyone in account"

The last thing we're missing is the ability to give anyone in an account the editor role on a specific file. To do that, we'll add another relation from files to accounts called account_global, and create a role derivation giving any member of the account the editor role on these files.

First, we'll create the new relation:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/relations \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "account_global",
    "name": "Account Global",
    "subject_resource": "account"
  }'
```

  </TabItem>
</Tabs>

Then let's add the derived role (note that since we're PATCHing the editor role, we also specify the existing relation):

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl https://api.us-west-2.permit.io/v2/schema/$permit_project/$permit_env/resources/file/roles/editor \
  -X PATCH \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "granted_to": {
        "users_with_role": [
            {
                "linked_by_relation": "parent",
                "on_resource": "folder",
                "role": "editor"
            },
            {
                "linked_by_relation": "account_global",
                "on_resource": "account",
                "role": "member"
            }
        ]
	}
  }'
```

  </TabItem>
</Tabs>

## Checking permissions

Now that we've configured everything and pushed some data, let's do a few permission checks to see what permissions Jane and John have.

First, we'll launch a Policy Decision Point (PDP). The PDP is a small container that fetches policy and data from Permit's cloud service and has all it needs to make decisions locally.

```bash
docker run -it \
    -e PDP_API_KEY=$permit_sdk_api_key \
    -p 7766:7000 \
    -p 8081:8081 \
    permitio/pdp-v2:latest
```

That second port (8081) is optional. You can use it if you want to interact directly with the OPA instance running within the PDP.

Let's first see if John can read the 2023_report file:

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl http://localhost:7766/allowed \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
        "user": {
            "key": "john@acme.com"
        },
        "resource": {
            "tenant": "default",
            "type": "file",
            "key": "2023_report"
        },
        "action": "read"
  }'
```

  </TabItem>
</Tabs>

We get back this result:
TODO

Meaning, John can read the file. Can he update it?

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl http://localhost:7766/allowed \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
        "user": {
            "key": "john@acme.com"
        },
        "resource": {
            "tenant": "default",
            "type": "file",
            "key": "2023_report"
        },
        "action": "update"
  }'
```

  </TabItem>
</Tabs>

No, because he only has viewer permissions. Can Jane update the file?

<Tabs groupId="language">
  <TabItem value="curl" label="cURL">

```bash
curl http://localhost:7766/allowed \
  -X POST \
  -H "Authorization: Bearer $permit_sdk_api_key" \
  -H "Content-Type: application/json" \
  -d '{
        "user": {
            "key": "jane@acme.com"
        },
        "resource": {
            "tenant": "default",
            "type": "file",
            "key": "2023_report"
        },
        "action": "update"
  }'
```

  </TabItem>
</Tabs>

Yes! Jane can update the file because she has editor permissions on the finance folder, and those permissions propagate through the derived role.
